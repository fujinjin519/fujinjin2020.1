<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
     <script>
        // 1. let n=10;
        //  setTimeout(() => {
        //      n++
        //      console.log(n); //11
             
             
        //  }, 1000);
        //  console.log(n);  // 10 输出顺序10，11定时器异步的不会等，先执行10，1秒后再执行11


        //   2. let n=10;
        //  setTimeout(() => {
        //      n++
        //      console.log(n); //11
             
             
        //  }, 0);
        //  console.log(n);  // 10 输出顺序10，11定时器异步的不会等，计算时间设置为0秒，浏览器有一个最小等待的时间，输出顺序还是10，11.
       
        //事件触发时候，根据浏览器有个最小等待时间 ，假设最小等待时间是5s,整体运动时间是1000ms.触发的次数就是1000/5=200次

        //获取代码执行需要的时间，（受电脑配置的影响
          
       
        // let n=10
        // setTimeout(() => {
        //     n++
        //     console.log(n); //11(3)
        // }, 0);
        // console.log(n);  //10(1)
        // for(let i=0;i<9999;i++){
        //     //循环到一半的时候，定时器到达时间
        //     console.log(n); //10(2)
            
        // }
      //底层原理：
        //进程是一个程序，线程是需要处理的事情，如果处理多个事情，会开辟多个线程，js是单线程（js代码一次只能做一个事情），浏览器是多线程，它会分配（GUI渲染代码），
        //同步：单线程，任务依次执行，上面的任务没完成，下面的代码不会执行（会等）
        //for循环是同步的。如果遇到一个死循环，会阻断整个页面的渲染，当前页面只会处理整个死循环，出不来了
        
        //异步：多线程，同时处理很多事情，但是js中的异步编程是利用浏览器的相关机制构造出来的异步效果，（不会等）
        //异步编程的有：定时器，事件绑定，ajax的异步请求，promise/async/await
        //设置定时器是同步，间隔多少秒执行函数是异步的
        //EventQueue事件队列(浏览器默认开辟的)：js代码遇到的异步操作，都先放置到事件队列中。对于事件队列来说，浏览器又会开辟一个定时器线程，来计算有没有到达时间，当遇到for循环的时候，它正在循环，不会管定时器，就算到时间也不行，
        //只有GUi线程里代码渲染完，空闲下来，（栈中的同步任务代码都执行完，）才会去事件队列中找到到达时间的任务，找定时器，把找到的任务，放到栈中执行（GUi中执行)这中过程叫EVENTLOOp（事件循环）
 
        
    </script>
</body>
</html>