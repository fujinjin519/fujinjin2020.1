<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!-- 
    浏览器渲染页面的主体
    浏览器--服务器，通过http request 向服务器发送请求,代码从上到下渲染，network 
    服务器把指定文的代码返回给客户端，http reaponse 服务器的代码html.css，js


    
    进程：每开一个应用程序，页面。开辟一个进程，页面里还有默认的进程
    线程：每个进程还会做多个事情，同时做多个事情。会开辟多个线程
    进程包含了线程，进程比线程大。
    浏览器是多线程，页面加载，渲染js是单线程
    
    浏览器同步异步编程：
    同步：一次只能处理一件事情，当前这件事情处理完，才能继续处理下一件事情
    异步：同时可以执行多个事情，一般是基于多线程并发完成，js的异步变成有自己的特殊处理方法
   
   
    浏览器渲染页面的步骤 
    1.DOM树（所有的html)-CSSOM树(css样式）-RENDER-TREE渲染树，根据渲染树在设备的视口中进行结构和位置的相关计算，布局或重排/回流
    2.根据渲染树以及回流得到的几何信息。得到节点的绝对像素，
    
    DOM的回流和重会：
    重绘： 样式改变，
    回流：大小位置变化，所有元素重新计算，会引发回流，一旦发生回流，重新计算完后，还需要重绘，回流会引发重绘
    第一次渲染页面的时候：触发一次回流和重绘
    
    性能优化：避免回流 让框架帮我们根据数据渲染视图（框架内部本身对于DOM的回流和重绘以及其它性能优化做的非常好） 
   
    当修改样式的时候，在老版本的浏览器，分别改了三次样式（涉及了位置或者大小的改变），所以触发三次回流和重绘。
    因为现代浏览器中默认增加了，“渲染队列机制”，以此来减少DOM的回流和重会。引发一次dom的回流和重会
    因为遇到修改样式的代码，先放到渲染队列，继续看下面一行的代码是否还为修改样式的代码，如果是继续增加到渲染队列中，直到下面的代码不再是修改样式的，而是获取的样式代码。此时不再向渲染队列中增加，把之前的渲染队列中要修改的样式一次性渲染到页面中，引发一次
     避免dom的多次回流和重会
     放弃操作dom,用框架数据驱动视图
     解决方案一：分离读写 只会有一次的dom回流和重会   
               手动分离读写的需求：先设置动画，渲染后，再去改变样式
     解决方案二：集中改变样式
     解决方案三：在动态操作DOM结构中的优化（如：数据绑定）
     
     文档碎片：临时创建的一个存放文档的容器。我们可以把新创建的li,存放到容器当中，当所有的li都存储完，我们统一把容器中的内容增加到页面中（只触发一次）
     let frag=document。createDoucumentFragment()
     真实项目中，有一个和文档碎片类似的方式，也是把要创建的li事先存储好，最后统一放到页面中渲染（字符串拼接）



   
   
    










   -->
   
   <script>

    </script>
</body>
</html>